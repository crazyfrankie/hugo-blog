<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Crazyfrank 的博客</title>
        <link>http://localhost:1313/zh/posts/</link>
        <description>所有文章 | Crazyfrank 的博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>axu9417@gmail.com (crazyfrank)</managingEditor>
            <webMaster>axu9417@gmail.com (crazyfrank)</webMaster><atom:link href="http://localhost:1313/zh/posts/" rel="self" type="application/rss+xml" /><item>
    <title>架构设计--评论系统</title>
    <link>http://localhost:1313/zh/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</link>
    <pubDate>Thu, 11 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</guid>
    <description><![CDATA[<p>架构设计最重要的就是<strong>理解整个产品体系在系统中的定位</strong>。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。</p>]]></description>
</item>
<item>
    <title>架构设计--评论系统</title>
    <link>http://localhost:1313/zh/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</link>
    <pubDate>Thu, 11 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</guid>
    <description><![CDATA[<p>今天讲讲旁路缓存策略。</p>
<p>一般来说我们在业务中引入缓存，涉及到三种操作数据库和缓存的方式：</p>
<ul>
<li>读穿：
<ol>
<li>应用读数据。</li>
<li>查 Redis。命中则返回。</li>
<li>未命中则查 MySQL。</li>
<li>从 MySQL 取到数据后，写入 Redis。</li>
<li>返回数据。</li>
</ol>
</li>
<li>写穿：
<ol>
<li>应用更新数据。</li>
<li>代码同时（或在同一个事务中）执行：</li>
</ol>
<ul>
<li>更新 MySQL 数据库。</li>
<li>更新（或失效）Redis 中的对应缓存。</li>
</ul>
</li>
<li>旁路缓存：
<ul>
<li>读操作：采用 “读穿” 策略。
<ul>
<li>Cache Hit -&gt; 返回缓存数据。</li>
<li>Cache Miss -&gt; 从 DB 读，回填 Cache，再返回。</li>
</ul>
</li>
<li>写操作：先更新数据库，然后删除（失效）缓存。
<ul>
<li>这是“旁路缓存”策略的精髓——“先更新数据库，再删缓存”。</li>
</ul>
</li>
</ul>
</li>
</ul>]]></description>
</item>
<item>
    <title>以日志处理浅谈去中心化</title>
    <link>http://localhost:1313/zh/posts/%E4%BB%A5%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E6%B5%85%E8%B0%88%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/</link>
    <pubDate>Fri, 05 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/%E4%BB%A5%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E6%B5%85%E8%B0%88%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/</guid>
    <description><![CDATA[<p>本文通过日志处理的角度来探讨去中心化系统的设计思路和实现方案。</p>
<h2 id="去中心化系统概述">去中心化系统概述</h2>
<p>去中心化是分布式系统设计中的重要概念，它通过将控制权分散到多个节点来提高系统的可靠性和容错性。</p>]]></description>
</item>
<item>
    <title>DDD 的一些思考</title>
    <link>http://localhost:1313/zh/posts/ddd-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
    <pubDate>Thu, 04 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/ddd-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
    <description><![CDATA[<h2 id="项目介绍">项目介绍</h2>
<p>叠甲，写这篇文章主要是分享在看 DDD 的项目实践中的一些学习感悟，因为本人懒得看理论，所以都只是猜测 DDD 要这么设计。具体还是要参考 DDD 官方网站： <a href="https://domain-driven-design.org/zh/ddd-concept-reference.html" target="_blank" rel="noopener noreffer ">DDD 概念介绍</a></p>]]></description>
</item>
<item>
    <title>日志与 Error</title>
    <link>http://localhost:1313/zh/posts/%E6%97%A5%E5%BF%97%E4%B8%8E-error/</link>
    <pubDate>Wed, 03 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/%E6%97%A5%E5%BF%97%E4%B8%8E-error/</guid>
    <description><![CDATA[<h2 id="日志与-error">日志与 Error</h2>
<p>一般来说在我们的项目中，按照严格分层的结构划分的话，大致是 <code>handler</code>、<code>service</code>（DDD 中细分为 <code>application</code> 和
<code>domain</code> ），<code>dao</code>。</p>
<p>对于 <code>dao</code> 层，如果出现错误，我们的处理方式是直接上抛，选择性的打日志处理错误，比如可能有些接口涉及到在 <code>dao</code>层进行参数校验、手动管理事务等，需要日志记录，但错误仍然是直接上抛。</p>]]></description>
</item>
<item>
    <title>DB-Cache 一致性问题</title>
    <link>http://localhost:1313/zh/posts/db-cache-%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link>
    <pubDate>Tue, 02 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/db-cache-%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid>
    <description><![CDATA[<p>如何保证缓存和数据库一致性，这是一个老生常谈的话题了。</p>
<p>但很多人对这个问题，依旧有很多疑惑：</p>
<ul>
<li>到底是更新缓存还是删缓存？</li>
<li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li>
<li>为什么要引入消息队列保证一致性？</li>
<li>延迟双删会有什么问题？到底要不要用？</li>
<li>…</li>
</ul>
<h2 id="引入缓存提高性能">引入缓存提高性能</h2>
<p>我们从最简单的场景开始讲起。</p>]]></description>
</item>
<item>
    <title>MVCC 及 MySQL 日志</title>
    <link>http://localhost:1313/zh/posts/mvcc-%E5%8F%8A-mysql-%E6%97%A5%E5%BF%97/</link>
    <pubDate>Tue, 02 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/mvcc-%E5%8F%8A-mysql-%E6%97%A5%E5%BF%97/</guid>
    <description><![CDATA[<p>在 <strong>MVCC</strong> 机制下，<strong>Redo Log 和 Bin Log 主要在事务提交时发挥作用</strong> ，它们的作用和触发时机如下：</p>
<hr>
<h3 id="事务执行过程中的日志行为">事务执行过程中的日志行为</h3>
<p>当执行：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-sql">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="复制到剪贴板"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">UPDATE</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">26</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span></span></span></code></pre></div></div>
<p>MySQL 的 <strong>事务执行顺序</strong> （结合 MVCC + 日志）如下：</p>]]></description>
</item>
<item>
    <title>负载均衡</title>
    <link>http://localhost:1313/zh/posts/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
    <pubDate>Tue, 02 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
    <description><![CDATA[<h2 id="概览">概览</h2>
<p>在分布式环境下，各个微服务都会有不同的实例，服务注册和服务发现解决了“有哪些可用实例”的问题，剩下面临的就是，“这么多可用实例，我该把请求发给谁？”。直觉来说，大部分人如果听过一些专业名词，此时会直接想到“负载均衡”。那负载均衡到底是什么呢？</p>]]></description>
</item>
<item>
    <title>感悟</title>
    <link>http://localhost:1313/zh/posts/%E6%84%9F%E6%82%9F/</link>
    <pubDate>Mon, 01 Sep 2025 10:00:00 &#43;0800</pubDate>
    <author>crazyfrank</author>
    <guid>http://localhost:1313/zh/posts/%E6%84%9F%E6%82%9F/</guid>
    <description><![CDATA[<p>人的肉体是过去，意识是现在和未来。</p>]]></description>
</item>
</channel>
</rss>
