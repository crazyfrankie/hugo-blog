<!DOCTYPE html>
<html lang="en-US">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>DB-Cache Consistency Problem - Crazyfrank&#39;s Blog</title><meta name="Description" content="Crazyfrank&#39;s English Blog"><meta property="og:url" content="http://localhost:1313/en/article/">
  <meta property="og:site_name" content="Crazyfrank&#39;s Blog">
  <meta property="og:title" content="DB-Cache Consistency Problem">
  <meta property="og:description" content="How to ensure the consistency between cache and database is a topic that has been discussed over and over again.
But many people still have a lot of doubts about this issue:
Should the cache be updated or deleted? Should I choose to update the database first and then delete the cache, or to delete the cache first and then update the database? Why introduce message queues to ensure consistency? What problems may arise from delaying double deletion? Should we use it or not? â€œâ€¦â€">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-02T10:00:00+08:00">
    <meta property="article:modified_time" content="2025-09-02T10:00:00+08:00">
    <meta property="article:tag" content="Data Consistency">
    <meta property="article:tag" content="DB">
    <meta property="article:tag" content="Cache">
    <meta property="og:image" content="http://localhost:1313/logo.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/logo.png">
  <meta name="twitter:title" content="DB-Cache Consistency Problem">
  <meta name="twitter:description" content="How to ensure the consistency between cache and database is a topic that has been discussed over and over again.
But many people still have a lot of doubts about this issue:
Should the cache be updated or deleted? Should I choose to update the database first and then delete the cache, or to delete the cache first and then update the database? Why introduce message queues to ensure consistency? What problems may arise from delaying double deletion? Should we use it or not? â€œâ€¦â€">
<meta name="application-name" content="Crazyfrank&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Crazyfrank&#39;s Blog">
<meta name="referrer" content="no-referrer" /><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://localhost:1313/en/article/" /><link rel="prev" href="http://localhost:1313/en/life/" /><link rel="next" href="http://localhost:1313/en/ddd/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/css/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "DB-Cache Consistency Problem",
        "inLanguage": "en-US",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/localhost:1313\/en\/article\/"
        },"genre": "posts","keywords": "Data Consistency, DB, Cache","wordcount":  2660 ,
        "url": "http:\/\/localhost:1313\/en\/article\/","datePublished": "2025-09-02T10:00:00+08:00","dateModified": "2025-09-02T10:00:00+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "crazyfrank"
            },"description": ""
    }
    </script><script src="https://cdn.jsdelivr.net/npm/typeit@8.7.1/dist/index.umd.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><link rel="stylesheet" href="/css/header-links.css">
        <script src="/js/header-links.js"></script>
    </head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script>
          const query = window.matchMedia('(prefers-color-scheme: dark)');
          function applyTheme() {
            let theme = window.localStorage?.getItem('theme') || 'auto';
            let isDark = theme === 'dark' || (theme === 'auto' && query.matches);
            document.body.setAttribute('theme', isDark? 'dark' : 'light');
            document.body.setAttribute('cfg-theme', theme);
          }

          applyTheme();
          query.addEventListener('change', applyTheme);
        </script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/en/" title="Crazyfrank&#39;s Blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/en/posts/"> Posts </a><a class="menu-item" href="/en/tags/"> Tags </a><a class="menu-item" href="/en/categories/"> Categories </a><a class="menu-item" href="/en/search/"> Search </a><a class="menu-item" href="/"> ðŸ‡¨ðŸ‡³ ä¸­æ–‡ </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="Select Language">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/article/">ç®€ä½“ä¸­æ–‡</option><option value="/en/article/" selected>English</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/en/" title="Crazyfrank&#39;s Blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/en/posts/" title="">Posts</a><a class="menu-item" href="/en/tags/" title="">Tags</a><a class="menu-item" href="/en/categories/" title="">Categories</a><a class="menu-item" href="/en/search/" title="">Search</a><a class="menu-item" href="/" title="">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="Select Language">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/article/">ç®€ä½“ä¸­æ–‡</option><option value="/en/article/" selected>English</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">DB-Cache Consistency Problem</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://hugo.crazyfrank.top/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>crazyfrank</a></span>&nbsp;<span class="post-category">included in <a href="/en/categories/technology/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Technology</a>&nbsp;<a href="/en/categories/backend/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Backend</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2025-09-02">2025-09-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;2660 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;13 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents"></nav></div>
            </div><div class="content" id="content"><p>How to ensure the consistency between cache and database is a topic that has been discussed over and over again.</p>
<p>But many people still have a lot of doubts about this issue:</p>
<p>Should the cache be updated or deleted?
Should I choose to update the database first and then delete the cache, or to delete the cache first and then update the database?
Why introduce message queues to ensure consistency?
What problems may arise from delaying double deletion? Should we use it or not?
&ldquo;&hellip;&rdquo;</p>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
<p>Introducing cache improves performance</p>
<p>Let&rsquo;s start with the simplest scenario.</p>
<p>If your business is in its infancy and the traffic is very small, then whether it is a read request or a write request, you can directly operate the database. At this time, your architecture model is like this:</p>
<p>! <a href="/images/db-cache/img-1.png" rel=""></a></p>
<p>However, as your business volume grows, the number of project requests becomes increasingly large. If you read data from the database every time at this point, there will definitely be performance issues.</p>
<p>At this stage, the common practice is to introduce &ldquo;caching&rdquo; to enhance read performance, and the architectural model becomes like this:</p>
<p>! <a href="/images/db-cache/img-2.png" rel=""></a></p>
<p>Among the current outstanding cache middleware, Redis stands out. It not only has extremely high performance but also offers many friendly data types, which can well meet our business needs.</p>
<p>But after introducing cache, you will face a problem: Previously, the data only existed in the database, but now it needs to be read in the cache. How exactly should it be stored? **</p>
<p>The simplest and most direct solution is to &ldquo;flush all the data into the cache&rdquo; :</p>
<p>The data in the database is fully flushed into the cache (without setting the expiration time)
Write requests only update the database, not the cache
Start a scheduled task to update the database data to the cache at regular intervals</p>
<p>! <a href="/images/db-cache/img-3.png" rel=""></a></p>
<p>The advantage of this solution is that all read requests can directly &ldquo;hit&rdquo; the cache without the need to check the database, resulting in extremely high performance.</p>
<p>However, the drawbacks are also quite obvious. There are two problems:</p>
<ol>
<li>** Low cache utilization ** : Data that is not frequently accessed remains in the cache</li>
<li>** Data Inconsistency ** : Since the cache is refreshed &ldquo;at regular intervals&rdquo;, there is an inconsistency between the cache and the database (depending on the execution frequency of the scheduled tasks).</li>
</ol>
<p>Therefore, this solution is generally more suitable for business scenarios where the business volume is small and the requirements for data consistency are not high.</p>
<p>Then, if our business volume is large, how can we solve these two problems?</p>
<p>Cache utilization and consistency issues</p>
<p>Let&rsquo;s first look at the first question: How to improve cache utilization?</p>
<p>To maximize cache utilization, the solution that comes to mind easily is to retain only the most recently accessed &ldquo;hot data&rdquo; in the cache. But how exactly should it be done?</p>
<p>We can optimize it in this way</p>
<p>The write request still only writes to the database
A read request first reads the cache. If the cache does not exist, it reads from the database and rebuilds the cache
At the same time, the expiration time is set for all the data written into the cache</p>
<p>! <a href="/images/db-cache/img-4.png" rel=""></a></p>
<p>In this way, the data that is not frequently accessed in the cache will gradually &ldquo;expire&rdquo; and be eliminated over time. Eventually, what is retained in the cache are all frequently accessed &ldquo;hot data&rdquo;, and the utilization rate of the cache is maximized.</p>
<p>Let&rsquo;s take a look at the issue of data consistency again.</p>
<p>To ensure that the cache and the database are &ldquo;real-time&rdquo; consistent, it is no longer possible to use scheduled tasks to refresh the cache.</p>
<p>So, when data is updated, we not only have to operate on the database but also on the cache at the same time. The specific operation is that when modifying a piece of data, not only the database but also the cache should be updated together.</p>
<p>However, both the database and the cache are updated, and there is a sequence issue. Therefore, there are two corresponding solutions:</p>
<p>Update the cache first, then the database
2. Update the database first, then the cache</p>
<p>Which plan is better?</p>
<p>For now, let&rsquo;s not consider the issue of concurrency. Under normal circumstances, no matter which comes first or second, we can keep the two consistent. But now, we need to focus on the &ldquo;abnormal&rdquo; situation.</p>
<p>Since the operation is divided into two steps, it is very likely that there will be a situation where &ldquo;the first step succeeds and the second step fails&rdquo;.</p>
<p>Let&rsquo;s analyze these two plans one by one.</p>
<ol>
<li>Update the cache first, then the database</li>
</ol>
<p>If the cache update is successful but the database update fails, then at this time, the latest value is in the cache, but the &ldquo;old value&rdquo; is in the database.</p>
<p>Although the read request can hit the cache at this time and obtain the correct value, once the cache &ldquo;expires&rdquo;, the &ldquo;old value&rdquo; will be read from the database, and the cache reconstruction will also be based on this old value.</p>
<p>At this point, users will find that the data they previously modified has &ldquo;reverted&rdquo;, which will have an impact on their business.</p>
<ol start="2">
<li>Update the database first, then update the cache</li>
</ol>
<p>If the database update is successful but the cache update fails, then at this time, the latest value is in the database and the &ldquo;old value&rdquo; is in the cache.</p>
<p>All subsequent read requests read old data. Only when the cache &ldquo;expires&rdquo; can the correct value be obtained from the database.</p>
<p>At this point, users will find that they have just modified the data but cannot see the changes. It will take some time for the data to be updated, which will also have an impact on the business.</p>
<p>It can be seen that no matter who comes first or later, whenever the latter experiences an anomaly, it will have an impact on the business. So how can this problem be solved?</p>
<p>Don&rsquo;t worry. I will provide the corresponding solutions in detail later.</p>
<p>Let&rsquo;s continue our analysis. Besides the issue of operation failure, what other scenarios could affect data consistency?</p>
<p>Here we also need to pay close attention to: ** Concurrency issues **.</p>
<p>Consistency issues caused by concurrency</p>
<p>Suppose we adopt the solution of &ldquo;updating the database first and then the cache&rdquo;, and both steps can be &ldquo;successfully executed&rdquo;, what would the situation be like if there is concurrency?</p>
<p>If there are two threads, Thread A and Thread B, and they need to update &ldquo;the same piece of data&rdquo;, the following scenario will occur:</p>
<p>Thread A updates the database (X = 1)
Thread B updates the database (X = 2)
3. Thread B updates the cache (X = 2
4. Thread A updates the cache (X = 1</p>
<p>The final value of X is 1 in the cache and 2 in the database, resulting in an inconsistency.</p>
<p>That is to say, although A occurred before B, the time B spent operating on the database and cache was shorter than that of A, causing a &ldquo;disorder&rdquo; in the execution sequence. Ultimately, this data result did not meet expectations.</p>
<p>Similarly, adopting the approach of &ldquo;updating the cache first and then the database&rdquo; will also lead to similar issues, which will not be elaborated here.</p>
<p>So how can this problem be solved? The common solution here is to add a &ldquo;distributed lock&rdquo;.</p>
<p>Two threads need to modify &ldquo;the same piece of data&rdquo;. Before each thread makes the change, it first applies for a distributed lock. Only the thread that obtains the lock is allowed to update the database and cache. The thread that fails to obtain the lock returns a failure and waits for the next retry.</p>
<p>The purpose of doing this is to allow only one thread to operate on data and cache, avoiding concurrent issues.</p>
<p>In addition, when evaluating this solution from the perspective of &ldquo;cache utilization&rdquo;, it is also not very recommended.</p>
<p>This is because every time the data changes, the cache is updated &ldquo;mindlessly&rdquo;, but the data in the cache may not be &ldquo;read immediately&rdquo;, which may lead to a lot of infrequently accessed data being stored in the cache, wasting cache resources.</p>
<p>Moreover, in many cases, the values written to the cache do not correspond one-to-one with those in the database. It is very likely that the database is queried first, and then a value is obtained through a series of &ldquo;calculations&rdquo; before being written to the cache.</p>
<p>It can be seen from this that this solution of &ldquo;updating the database + updating the cache&rdquo; not only has a low cache utilization rate but also leads to a waste of machine performance.</p>
<p>So at this point, we need to consider another solution: ** Delete the cache **.</p>
<p>Can deleting the cache ensure consistency?</p>
<p>There are also two corresponding solutions for deleting the cache:</p>
<p>First, delete the cache, and then update the database
2. Update the database first and then delete the cache</p>
<p>Similarly, let&rsquo;s first look at the situation where the &ldquo;second step&rdquo; operation fails.</p>
<p>First, delete the cache, then update the database. If the second operation fails and the database is not updated successfully, the next time you read the cache and find it does not exist, read from the database and rebuild the cache. At this point, the database and the cache remain consistent.</p>
<p>However, if the database is updated first and then the cache is deleted, the second operation fails. The database shows the latest value, while the cache contains the old value, resulting in an inconsistency. So, this plan still has problems.</p>
<p>In conclusion, similar to the issues mentioned earlier, there is still a risk of inconsistency if the second step fails.</p>
<p>Ok, let&rsquo;s take a look at the &ldquo;concurrency&rdquo; issue again. This is the &ldquo;key point&rdquo; we need to focus on.</p>
<p>Delete the cache first, and then update the database</p>
<p>If two threads need to concurrently &ldquo;read and write&rdquo; data, the following scenarios may occur:</p>
<p>Thread A needs to update X = 2 (original value X = 1)
Thread A deletes the cache first
Thread B reads the cache and finds it does not exist. It then reads the old value (X = 1) from the database.
Thread A writes the new value to the database (X = 2)
Thread B writes the old value to the cache (X = 1).</p>
<p>The final value of X is 1 (the old value) in the cache and 2 (the new value) in the database, resulting in an inconsistency.</p>
<p>It can be seen that when the cache is deleted first and then the database is updated, there are still cases of data inconsistency when &ldquo;read + write&rdquo; concurrency occurs.</p>
<p>Update the database first and then delete the cache</p>
<p>It is still two threads concurrently &ldquo;reading and writing&rdquo; data:</p>
<ol>
<li>X does not exist in the cache (database X = 1)
Thread A reads the database and obtains the old value (X = 1)
Thread B updates the database (X = 2)</li>
<li>Thread B deletes the cache
Thread A writes the old value to the cache (X = 1)</li>
</ol>
<p>Ultimately, the value of X is 1 (the old value) in the cache and 2 (the new value) in the database, and inconsistencies also occur.</p>
<p>This situation is theoretically possible, but is it really possible in reality?</p>
<p>In fact, the probability is &ldquo;very low&rdquo;, because it must meet three conditions:</p>
<ol>
<li>The cache has just expired</li>
<li>Concurrent read requests and write requests
The time required to update the database and delete the cache (steps 3-4) is shorter than that for reading the database and writing to the cache (Steps 2 and 5).</li>
</ol>
<p>On second thought, the probability of condition 3 occurring is actually very low.</p>
<p>Because writing to a database usually involves &ldquo;locking&rdquo; first, it typically takes longer to write to a database than to read it.</p>
<p>From this perspective, the solution of &ldquo;updating the database first and then deleting the cache&rdquo; can ensure data consistency.</p>
<p>Therefore, we should adopt this solution to operate the database and cache.</p>
<p>Ok, having resolved the concurrency issue, let&rsquo;s move on to the problem left over from earlier, which was the &ldquo;failed&rdquo; execution in the second step, resulting in data inconsistency.</p>
<p>How to ensure that both steps are executed successfully?</p>
<p>As we analyzed earlier, whether it is updating the cache or deleting the cache, if the second step fails, it will lead to inconsistency between the database and the cache.</p>
<p>Ensuring the successful execution of the second step is the key to solving the problem.</p>
<p>Think about it. If an exception occurs during the execution of a program, what is the simplest solution?</p>
<p>The answer is: ** Retry **.</p>
<p>Yes, actually we can do it this way here as well.</p>
<p>Whether we operate on the cache first or the database first, if the latter fails to execute, we can initiate a retry and try our best to make &ldquo;compensation&rdquo;.</p>
<p>Does this mean that as long as the execution fails, we can just &ldquo;mindlessly retry&rdquo;?</p>
<p>The answer is no. The reality is often not as simple as we think. The problem with retrying immediately after failure lies in:</p>
<p>There is a high probability that an immediate retry will &ldquo;still fail&rdquo;
How many times should the &ldquo;retry count&rdquo; be set reasonably?
Retries will constantly &ldquo;occupy&rdquo; this thread&rsquo;s resources and be unable to serve requests from other clients</p>
<p>See? Although we want to solve the problem by retrying, this &ldquo;synchronous&rdquo; retry solution is still not rigorous.</p>
<p>Then what should be the better plan?</p>
<p>The answer is: &ldquo;Asynchronous retry&rdquo;. What is asynchronous retry?</p>
<p>In fact, it is to write the retry request to the &ldquo;message queue&rdquo;, and then have a dedicated consumer retry it until it is successful.</p>
<p>Or, to avoid the failure of the second step, we can place the cache operation step directly into the message queue and let the consumer operate the cache.</p>
<p>At this point, you might ask, could writing a message queue also fail? Moreover, introducing a message queue adds even more maintenance costs. Is it worth it to do so?</p>
<p>This is a good question. But let&rsquo;s consider this: If you keep retrying in a thread that failed to execute and haven&rsquo;t achieved success yet, and the project &ldquo;restarts&rdquo; at this point, then this retry request will be &ldquo;lost&rdquo;, and this piece of data will remain inconsistent.</p>
<p>So, here we must place the retry message or the second-step operation in another &ldquo;service&rdquo;, and this service is most suitable to be called a &ldquo;message queue&rdquo;. This is because the characteristics of the message queue precisely meet our requirements:</p>
<p>** * Message queue ensures reliability ** : Messages written to the queue will not be lost before successful consumption (there is no need to worry even if the project is restarted)
** * Message queue ensures successful message delivery ** : The downstream pulls messages from the queue. Messages will only be deleted after successful consumption; otherwise, messages will continue to be delivered to consumers (meeting our retry requirements).</p>
<p>As for the issues of queue writing failure and the maintenance cost of message queues:</p>
<p>** * Failed to write to the queue ** : The probability of &ldquo;simultaneous failure&rdquo; when operating the cache and writing to the message queue is actually very small
** * Maintenance cost ** : Message queues are generally used in our projects, and the maintenance cost has not increased significantly</p>
<p>So, introducing a message queue to solve this problem is quite appropriate. At this point, the architectural model becomes like this:</p>
<p>! <a href="/images/db-cache/img-4.png" rel=""></a></p>
<p>Then, if you really don&rsquo;t want to write a message queue in the application, is there a simpler solution that can still ensure consistency?</p>
<p>There are still solutions. This is a relatively popular solution in recent years: ** Subscribe to the database change log and then operate the cache **.</p>
<p>Specifically speaking, it&rsquo;s our business</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-09-02</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on X" data-sharer="x" data-url="http://localhost:1313/en/article/" data-title="DB-Cache Consistency Problem" data-hashtags="Data Consistency,DB,Cache"><i class="fab fa-x-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://localhost:1313/en/article/" data-hashtag="Data Consistency"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="http://localhost:1313/en/article/" data-title="DB-Cache Consistency Problem"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://localhost:1313/en/article/" data-title="DB-Cache Consistency Problem"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on å¾®åš" data-sharer="weibo" data-url="http://localhost:1313/en/article/" data-title="DB-Cache Consistency Problem"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Diaspora" data-sharer="diaspora" data-url="http://localhost:1313/en/article/" data-title="DB-Cache Consistency Problem" data-description=""><i class="fab fa-diaspora fa-fw" aria-hidden="true"></i></a><a href="https://t.me/share/url?url=http%3a%2f%2flocalhost%3a1313%2fen%2farticle%2f&amp;text=DB-Cache%20Consistency%20Problem" target="_blank" title="Share on Telegram"><i class="fab fa-telegram fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/en/tags/data-consistency/">Data Consistency</a>,&nbsp;<a href="/en/tags/db/">DB</a>,&nbsp;<a href="/en/tags/cache/">Cache</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/en/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/en/life/" class="prev" rel="prev" title="realisation"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>realisation</a>
            <a href="/en/ddd/" class="next" rel="next" title="Some Thoughts on DDD">Some Thoughts on DDD<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.148.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.3.1-DEV"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://hugo.crazyfrank.top/" target="_blank">crazyfrank</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a>
        </div>

        <div id="fixed-buttons-hidden"><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script>window.config={"search":{"maxResultLength":10,"snippetLength":30,"highlightTag":"em","noResultsFound":"æ²¡æœ‰æ‰¾åˆ°ç»“æžœ"},"toc":{"enable":true,"auto":true}};</script>

<script>
window.ClipboardJS = function(element) {
  this.element = element;
  this.callbacks = {};
  element.addEventListener('click', () => {
    const text = element.getAttribute('data-clipboard-text');
    navigator.clipboard.writeText(text).then(() => {
      if (this.callbacks.success) this.callbacks.success();
    });
  });
};
window.ClipboardJS.prototype.on = function(event, callback) {
  this.callbacks[event] = callback;
};
</script>

<script src="/js/theme.js"></script>

<script>

document.addEventListener('DOMContentLoaded', function() {
  setTimeout(function() {
    document.querySelectorAll('.details.admonition').forEach(function(details) {
      const summary = details.querySelector('.details-summary');
      if (summary) {
        summary.addEventListener('click', function() {
          details.classList.toggle('open');
        });
      }
    });
  }, 300);
});
</script>

<script>

setTimeout(function() {
  document.querySelectorAll('.code-block').forEach(function(codeBlock) {
    const codeTitle = codeBlock.querySelector('.code-header > .code-title');
    const copyBtn = codeBlock.querySelector('.code-header .copy');
    
    if (codeTitle && !codeTitle.hasAttribute('data-cb-init')) {
      codeTitle.setAttribute('data-cb-init', 'true');
      codeTitle.addEventListener('click', function() {
        codeBlock.classList.toggle('open');
      });
    }
    
    if (copyBtn && !copyBtn.hasAttribute('data-cb-init')) {
      copyBtn.setAttribute('data-cb-init', 'true');
      const code = codeBlock.querySelector('code');
      if (code) {
        copyBtn.addEventListener('click', function() {
          navigator.clipboard.writeText(code.innerText).then(function() {
            const codeLines = code.querySelectorAll('span.cl');
            if (codeLines.length > 0) {
              codeLines.forEach(function(codeLine) {
                codeLine.classList.add('animate__animated', 'animate__flash');
                setTimeout(function() {
                  codeLine.classList.remove('animate__animated', 'animate__flash');
                }, 1000);
              });
            }
          });
        });
      }
    }
  });
}, 500);
</script>

<style>
.menu-item.language {
  display: none !important;
}
#language-select-desktop {
  display: none !important;
}
.search-form,
#search-input,
.search-loading,
.search-results {
  text-align: center !important;
}
</style>

<script>
const originalFetch = window.fetch;
window.fetch = function(url, options) {
  if (window.location.pathname.startsWith('/en/') && url === '/index.json') {
    url = '/en/index.json';
  }
  return originalFetch(url, options);
};

const originalOpen = XMLHttpRequest.prototype.open;
XMLHttpRequest.prototype.open = function(method, url, ...args) {
  if (window.location.pathname.startsWith('/en/') && url === '/index.json') {
    url = '/en/index.json';
  }
  return originalOpen.call(this, method, url, ...args);
};

document.addEventListener('DOMContentLoaded', function() {
  if (window.location.pathname.includes('/search/')) {
    const title = document.querySelector('h2');
    if (title) {
      title.style.cssText = `
        text-align: center !important;
        margin-top: 120px !important;
        margin-bottom: 60px !important;
        padding-top: 50px !important;
      `;
    }
  }
});
</script>
<script>
        setTimeout(function() {
            
            const content = {
                title: "Crazyfrank\u0027s Blog",
                subtitle: "Adversity reveals true strength"
            };
            
            
            document.querySelectorAll('.typeit').forEach(function(element) {
                if (element.id) {
                    let text = '';
                    if (element.id === 'id-1' || element.id === 'id-2') {
                        text = content.title;
                    } else if (element.id === 'id-3') {
                        text = content.subtitle;
                    }
                    
                    if (text) {
                        new TypeIt('#' + element.id, {
                            strings: text,
                            speed: 100,
                            waitUntilVisible: true
                        }).go();
                    }
                }
            });
        }, 600);
        </script>
    </body>
</html>
