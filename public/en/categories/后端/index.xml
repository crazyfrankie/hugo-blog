<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端 on Crazyfrank&#39;s Blog</title>
    <link>http://localhost:1313/en/categories/%E5%90%8E%E7%AB%AF/</link>
    <description>Recent content in 后端 on Crazyfrank&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <managingEditor>axu9417@gmail.com (crazyfrank)</managingEditor>
    <webMaster>axu9417@gmail.com (crazyfrank)</webMaster>
    <lastBuildDate>Tue, 02 Sep 2025 10:00:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/en/categories/%E5%90%8E%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DB-Cache 一致性问题</title>
      <link>http://localhost:1313/en/article/</link>
      <pubDate>Tue, 02 Sep 2025 10:00:00 +0800</pubDate><author>axu9417@gmail.com (crazyfrank)</author>
      <guid>http://localhost:1313/en/article/</guid>
      <description>&lt;p&gt;如何保证缓存和数据库一致性，这是一个老生常谈的话题了。&lt;/p&gt;&#xA;&lt;p&gt;但很多人对这个问题，依旧有很多疑惑：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;到底是更新缓存还是删缓存？&lt;/li&gt;&#xA;&lt;li&gt;到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？&lt;/li&gt;&#xA;&lt;li&gt;为什么要引入消息队列保证一致性？&lt;/li&gt;&#xA;&lt;li&gt;延迟双删会有什么问题？到底要不要用？&lt;/li&gt;&#xA;&lt;li&gt;…&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;引入缓存提高性能&#34;&gt;引入缓存提高性能&lt;/h2&gt;&#xA;&lt;p&gt;我们从最简单的场景开始讲起。&lt;/p&gt;&#xA;&lt;p&gt;如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;http://localhost:1313/svg/loading.min.svg&#34;&#xA;        data-src=&#34;http://localhost:1313/images/db-cache/img-1.png&#34;&#xA;        data-srcset=&#34;http://localhost:1313/images/db-cache/img-1.png, http://localhost:1313/images/db-cache/img-1.png 1.5x, http://localhost:1313/images/db-cache/img-1.png 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;/images/db-cache/img-1.png&#34;&#xA;        title=&#34;/images/db-cache/img-1.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。&lt;/p&gt;&#xA;&lt;p&gt;这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;http://localhost:1313/svg/loading.min.svg&#34;&#xA;        data-src=&#34;http://localhost:1313/images/db-cache/img-2.png&#34;&#xA;        data-srcset=&#34;http://localhost:1313/images/db-cache/img-2.png, http://localhost:1313/images/db-cache/img-2.png 1.5x, http://localhost:1313/images/db-cache/img-2.png 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;/images/db-cache/img-2.png&#34;&#xA;        title=&#34;/images/db-cache/img-2.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。&lt;/p&gt;&#xA;&lt;p&gt;但引入缓存之后，你就会面临一个问题：&lt;strong&gt;之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;最简单直接的方案是「全量数据刷到缓存中」：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据库的数据，全量刷入缓存（不设置失效时间）&lt;/li&gt;&#xA;&lt;li&gt;写请求只更新数据库，不更新缓存&lt;/li&gt;&#xA;&lt;li&gt;启动一个定时任务，定时把数据库的数据，更新到缓存中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;http://localhost:1313/svg/loading.min.svg&#34;&#xA;        data-src=&#34;http://localhost:1313/images/db-cache/img-3.png&#34;&#xA;        data-srcset=&#34;http://localhost:1313/images/db-cache/img-3.png, http://localhost:1313/images/db-cache/img-3.png 1.5x, http://localhost:1313/images/db-cache/img-3.png 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;/images/db-cache/img-3.png&#34;&#xA;        title=&#34;/images/db-cache/img-3.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。&lt;/p&gt;&#xA;&lt;p&gt;但缺点也很明显，有 2 个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存利用率低&lt;/strong&gt; ：不经常访问的数据，还一直留在缓存中&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据不一致&lt;/strong&gt; ：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。&lt;/p&gt;&#xA;&lt;p&gt;那如果我们的业务体量很大，怎么解决这 2 个问题呢？&lt;/p&gt;&#xA;&lt;h3 id=&#34;缓存利用率和一致性问题&#34;&gt;缓存利用率和一致性问题&lt;/h3&gt;&#xA;&lt;p&gt;先来看第一个问题，如何提高缓存利用率？&lt;/p&gt;&#xA;&lt;p&gt;想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？&lt;/p&gt;&#xA;&lt;p&gt;我们可以这样优化：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写请求依旧只写数据库&lt;/li&gt;&#xA;&lt;li&gt;读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存&lt;/li&gt;&#xA;&lt;li&gt;同时，写入缓存中的数据，都设置失效时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;http://localhost:1313/svg/loading.min.svg&#34;&#xA;        data-src=&#34;http://localhost:1313/images/db-cache/img-4.png&#34;&#xA;        data-srcset=&#34;http://localhost:1313/images/db-cache/img-4.png, http://localhost:1313/images/db-cache/img-4.png 1.5x, http://localhost:1313/images/db-cache/img-4.png 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;/images/db-cache/img-4.png&#34;&#xA;        title=&#34;/images/db-cache/img-4.png&#34; /&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
