[
{
  "title": "以日志处理浅谈去中心化",
  "content": "本文通过日志处理的角度来探讨去中心化系统的设计思路和实现方案。\n去中心化系统概述 去中心化是分布式系统设计中的重要概念，它通过将控制权分散到多个节点来提高系统的可靠性和容错性。\n在架构里，“去中心化”不是一定要“完全没有中心”，而是：\n不要有不可替代的单点，而是用 分布式、多对等节点 来分摊职责； 系统的可用性和扩展性 不依赖某一个关键节点。 日志处理 以 ELK 日志处理架构为例，\nELK 介绍 这里简单介绍一下图示结构： ELK 是一种日志处理架构，主要思想是将 AppServer 也就是各个微服务的日志统一使用 LogStash Agent 进行代理收集，经过分析、过滤后发送给远端的 Elastic Search 进行存储， Elastic Search 将数据以分片的形式压缩存储并提供多种 API 供用户查询，操作；用户同样的也可以直观的配置 Kibana Web 方便的对日志查询，并生成数据报表 在传统的中心化系统中，所有的请求都需要通过中央服务器处理，也就是 Server 角色，在本例中也就是 LogStash ，这往往会形成单点故障、集中式的热点问题： …",
  "uri": "/decentration/"
},
{
  "title": "DDD 的一些思考",
  "content": "项目介绍 叠甲，写这篇文章主要是分享在看 DDD 的项目实践中的一些学习感悟，因为本人懒得看理论，所以都只是猜测 DDD 要这么设计。具体还是要参考 DDD 官方网站： DDD 概念介绍\n最近字节开源了它们的 open-coze，前端是 React + TS，后端采用了 Go，刚好没有使用 Py 或者 TS，加上本人对 Go 了解多一点，于是开始学习。\n大致上项目结构是这样的：\n. ├── api ├── application ├── conf ├── crossdomain ├── domain ├── infra ├── internal ├── main.go ├── pkg └── types crossdomain 这里主要讲解 crossdomain 的设计理念，其他的设计跟官网提到的一致，所以可以参考官网。\n当我们遇到 A 模块的某个接口逻辑中涉及到对 B 模块的操作，而同时 B 模块所设计或者说提供的接口不足以满足 A 的要求，一般来说就是数据结构不一致：入参或出参。 所以在简易的设计架构中，有人往往会直接在 B 模块添加方法以满足 A 模块的调用，但这样其实是破坏了 …",
  "uri": "/ddd/"
},
{
  "title": "日志与 Error",
  "content": "日志与 Error 一般来说在我们的项目中，按照严格分层的结构划分的话，大致是 handler、service（DDD 中细分为 application 和 domain ），dao。\n对于 dao 层，如果出现错误，我们的处理方式是直接上抛，选择性的打日志处理错误，比如可能有些接口涉及到在 dao层进行参数校验、手动管理事务等，需要日志记录，但错误仍然是直接上抛。\n在 service层，我们遇到错误时，分为两种情况：业务预期内的错误、非业务错误。\n对于前者，我们的处理方式是，预先定义各种业务错误码， 在遇到时将其转换为 error 接口上抛，由 handler 转换为 resp code 返回给客户端，可选 Warn 日志（低频关键场景）。\n对于后者，错误通常是技术错误，不应由service 自身处理，而是交由调用方处理，那么我们在这里是打日志+错误上抛。这里的描述也不详尽，具体的可以参考下表：\n场景分类 处理方式 日志策略 是否向上抛 示例 1. 预期内的业务错误 返回自定义业务错误类型 可选Warn日志（低频关键场景） 是 ErrUserNotFound 2. …",
  "uri": "/log-error/"
},
{
  "title": "DB-Cache 一致性问题",
  "content": "如何保证缓存和数据库一致性，这是一个老生常谈的话题了。\n但很多人对这个问题，依旧有很多疑惑：\n到底是更新缓存还是删缓存？ 到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？ 为什么要引入消息队列保证一致性？ 延迟双删会有什么问题？到底要不要用？ … 引入缓存提高性能 我们从最简单的场景开始讲起。\n如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：\n但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。\n这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：\n当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。\n但引入缓存之后，你就会面临一个问题：之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？\n最简单直接的方案是「全量数据刷到缓存中」：\n数据库的数据，全量刷入缓存（不设置失效时间） 写请求只更新数据库，不更新缓存 启动一个定时任务，定时把数据库的数据，更新到缓存中 这个方案 …",
  "uri": "/db-cache/"
},
{
  "title": "感悟",
  "content": "人的肉体是过去，意识是现在和未来。\n",
  "uri": "/life/"
}]
